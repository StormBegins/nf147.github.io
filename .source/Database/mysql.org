#+TITLE: MySQL



* 安装与配置

MySQL/MariaDB:
- https://www.mysql.com/cn/
- http://mariadb.org

比如，MariaDB 的下载页面:
- https://downloads.mariadb.org/mariadb/10.3.9/

下载安装即可：
- 注意，要注意勾选“将utf8作为默认字符集”
- 安装过程中需要提供 root 用户的密码，需要记住
- 安装完后，需要将 bin 目录添加到环境变量中
- 可以选择将 mysqld 安装为 windows 服务，如果没有勾选，那么也可以手动创建服务

创建服务的方式:
#+BEGIN_SRC sh
  # 如果要删除相关服务，只需要在“管理员身份”的命令行窗口下面运行:
  # sc delete 服务名字

  # 将 MySQL 安装为服务的方式:
  "C:\Program Files\MariaDB 10.3\bin\mysqld.exe" install MyDB --defaults-file="C:\Program Files\MariaDB 10.3\my.ini"
#+END_SRC

在连接之前，需要启动服务器守护程序，可以通过下面两种方式之一:
1. 启动相关 windows 服务，比如 MySQL 服务
2. 通过命令行窗口，执行 ~mysqld --defaults-file=my.ini~ 命令

服务启动后，就可以通过客户端访问了:
#+BEGIN_SRC sh
  mysql -u root -p
  mysql -uroot -proot
  mysql -h 45.42.32.1 -P 9999 -uroot -p
#+END_SRC

* 数据库与账户

MySQL 在用户登录后（默认使用 root 用户登录），需要切换到一个 *database* 才能进行表的创建等操作。所有的表和数据都隶属于某个数据库。

刚安装完之后，MySQL 中有若干内置数据库：

[[file:img/clip_2018-09-05_07-24-23.png]]

想要切换到某个数据库下，使用 ~use~ 指令:
: use mysql

我们可以为自己的业务创建单独的数据库，比如，为我们的书店项目我们创建一个单独的数据库:
#+BEGIN_SRC sql
  create database bookstore;
  create database bookstore character set UTF8; -- 创建时可以指定字符集
  use bookstore;  -- 切换到数据库下
#+END_SRC

虽然 root 用户强大无比，但是使用 root 用户进行数据库操作不是一个好的行为。
所以我们需要为数据库的操作创建相关的用户:
#+BEGIN_SRC sql
  -- 特别需要注意，在 MySQL 中，账号由两部分组成:
  -- 1. user
  -- 2. host
  -- 即使 user 相同，只要 host 不同，也会被认为是不同账号。
  -- 这样可以非常方便对来自不同 ip 地址的访问进行精细的权限控制。
  -- 默认情况下，创建的用户 host 为 '%'，这是一个匹配符，跟模糊查询里的意思一样，表示匹配所有
  create user vip identified by 'vippp';             -- 所有连接
  create user vip@'127.0.0.1' identified by 'xxx';   -- 本地连接
  create user vip@'192.168.%' identified by 'yyy';   -- 192.168 网段的连接
#+END_SRC

新创建的用户没有多少权限，登录之后，只能访问操作 test 以及以 test 开头的数据库。
如果想让新用户有更多权限，就需要用到授权语句(DCL)：
#+BEGIN_SRC sql
  grant all on *.* to vip@'127.0.0.1';        -- 将所有数据库上的所有权利都授予通过本机连接的 vip 用户！
  grant all privileges on lagou.* to vip@'%'; -- 将数据库 lagou 上的所有权利都授予所有连接的 vip 用户!
  grant select on lagou.position to vip@'%';  -- 将 lagou 数据库上的 position 表的访问权限开放给所有 vip 用户。
#+END_SRC

如果想查看某个用户拥有的权限，只需要:
#+BEGIN_SRC sql
  show grants for vip@'%';
#+END_SRC

* 用户跟权限

用户跟权限的相关信息，都是保存在下面表中：
- mysql.user
- mysql.db/host/table/priv...

~mysql.user~ 是一个非常重要非常特殊的表，它保存了所有的账号信息，以及保存了账号的权限信息。

如果要操作用户和权限，有两种方式:
1. 使用相关的授权语句
2. 直接修改 mysql.user 表

*第一种方式*:
#+BEGIN_SRC sql
  -- 查看用户
  select current_user(), user();
  select * from mysql.user;

  -- 创建与授权
  create user 'xxx'@'host' identified by '密码';
  grant all on ttt.* to 'user'@'host' with grant options;

  -- 查看授权情况
  show grants for 'user'@'host';

  -- 用户的管理，删除密码等
  set password for 'user'@'host' = password('新密码');
  drop user vip;

  -- 授权的相对完整语法为:
  grant all/alter/create/drop/select/update/delete
        on *.* -- db.*/db.table
        to 'user'@'host'
        identified by '密码'
        with max_user_connections 2
             max_connections_pser_hour 5;
#+END_SRC


*第二种方式*:
#+BEGIN_SRC sql
  -- 增加用户
  insert into mysql.user(host, user, password) values (xx, yy, zz);

  -- 修改密码
  update mysql.user set password=password('新密码') where user='vip' and host='%';

  -- 修改权限
  update mysql.user set event_priv='Y' where user='vip' and host='%';

  -- 注意，使用 sql 语句修改用户跟权限之后，需要手动刷新权限表
  flush privileges;
#+END_SRC
* 基本命令

#+BEGIN_SRC sql
  -- 查询当前日期
  select now(), current_date, current_time;

  -- 查询当前用户
  select user(), current_user();

  -- 数据库
  show databases;
  use test;
#+END_SRC

* 创建表

#+BEGIN_SRC sql
  create table book1 (
     bookid int primary key
  );
  create table book2 (
     bookid int,
     primary key (bookid)
  );
  create table book3 (
     bookid int auto_increment primary key
  );
  create table book4 (
     bookid int auto_increment primary key,
     name varchar(30) not null,
     price float check (price >= 0)
  );
  create table book5 (
     bookid int auto_increment primary key,
     name varchar(30) not null,
     price float check (price >= 0),
     press varchar(50),
     authorid int references author (authorid)
     -- foreign  key(author) references author(authorid),
  );
  create table book6 (
     bookid int auto_increment,
     name varchar(30) not null,
     price float check (price >= 0),
     press varchar(50),
     authorid int,

     primary key (bookid),
     foreign key (authorid) references author (authorid)
  );
  create table book7 (
     bookid int auto_increment primary key,
     name varchar(30) not null,
     price float check (price >= 0),
     press varchar(50),
     authorid int
  );

  create table author (
    authorid int auto_increment,
    name varchar(30) not null,
    tel varchar(20),
    birth date,
    primary key (authorid)
  );



  -- 实际的导入情况，首先创建表，先不添加任何外键约束
  create table book (
     bookid int auto_increment primary key,
     name varchar(30) not null,
     price float check (price >= 0),
     press varchar(50),
     authorid int,
     publish_at datetime,
     created_at timestamp
  );
  create table author (
    authorid int auto_increment primary key,
    name varchar(30) not null,
    tel varchar(20),
    birth date
  );
  -- 在这里，执行所有的数据插入操作
  -- insert into book ...
  -- insert into author ...
  alter table book 
     add constraint fk_authorid
     foreign key (authorid)
     references author (authorid);
  -- 如果需要添加主键的话，语法如下
  alter table book
     add constraint pk_bookid
     primary key (bookid);
  -- 如果想删除掉的话
  alter table book
     drop foreign key fk_authorid;
#+END_SRC


其他:
#+BEGIN_SRC sql
  create table xxx if not exists (id int);

  create temporary table yyy (id int);

  create temporary table if not exists yyy (
         id bigint auto_increment,
         name varchar(20) not null unique, -- 唯一，不重复的
         birth datetime,
         gender enum('f', 'm'), -- Female Male
         minzu set('汉', '俄罗斯'),
         created_at timestamp,
         primary key (id)
  );


  create table aaa (id int auto_increment primary key, name varchar(20))
     default charset = gbk
     engine = InnoDB
     auto_increment = 7
     comment = `这只是一个测试表而已`;

  create table gbk_test2 (vvv varchar(4)) default charset = gbk;
  create table gbk_test3 (vvv varchar(4)) default charset = utf8;
  insert into gbk_test2 values ('中国');
  insert into gbk_test3 values ('中国');
  select * from gbk_test2;
  select * from gbk_test3;
  select length(vvv) from gbk_test2;
  select length(vvv) from gbk_test3;
  select char_length(vvv) from gbk_test2;
  select char_length(vvv) from gbk_test3;
#+END_SRC

一致性，完整性

| id | 名字      | xxx |
|----+-----------+-----|
|  1 | Java      |   2 |
|  2 | 太极剑法  |   1 |
|  3 | MySQL指南 |  22 |


| id | 名字   | 生日 |
|----+--------+------|
|  1 | 张三丰 | x    |
|  2 | 我     | y    |
|  3 | 你妹   | z    |

* 数据类型

大致分为 *6* 类:
1. *整数*: bit / bool / tinyint / smallint / mediumint / int / bitint
2. *浮点数*: float / double / decimal
3. *字符串*: char / varchar / tinytext / text / mediumtext / longtext
4. *BLOB(Binary Large Object)*: tinyblob / blob / mediumblob / longblob
5. *日期*: date(2018-9-6) / time (03:33:49) / datetime(2018-9-6 03:34:08) / timestamp
6. *其他*: binary / varbinary / enum / set / geometry / point / LineString ...

问题:
1. char 跟 varchar 有什么区别？
2. varchar 最多存储的长度是多少？
3. varchar 跟 text 类型有什么区别？
4. set/enum 该怎么去使用？

#+BEGIN_SRC sql
  create table char_demo 
  (
    aaa char(40),
    bbb varchar(40),
    ccc text(40)
  );

  insert into char_demo values ('123', '123', '123');

  select length(aaa), length(bbb), length(ccc) from char_demo;

  SET sql_mode = 'PAD_CHAR_TO_FULL_LENGTH';

  select length(aaa), length(bbb), length(ccc) from char_demo;
#+END_SRC

总结 Char vs Varchar vs Text:
1. char(n) 和 varchar(n) 中间的 n 代表字符的个数，不是字节的个数
2. 如果数据超过 n 的限制，那么数据将会被截断
3. char 是固定宽度，如果数据长度不满足 n，那么将会在右边用空格补齐；varchar 是变长宽度
4. varchar 是标准类型；text 不是标准类型
5. varchar 跟 text 都最大保存 65535 字节长度的数据。但是 text 还有 mediumtext/longtext 它可以支持存储更多的内容
6. varchar 的存储格式是 stored-inline, text 的存储格式是 off-record。一般情况来说，varchar 的速度要比 text 快

BLOB 类型，可以存储大字段。

ENUM 跟 SET 是两种比较特殊的字符串类型，他们对字段进行了一定约束:
#+BEGIN_SRC sql
  create table person (
         id int auto_increment primary key,
         name varchar(30) not null,
         gender char(2) -- 限制，只有 男、女、未知
  );


  create table person (
         id int auto_increment primary key,
         name varchar(30) not null,
         gender enum('男', '女', '未知') -- 限制，只有 男、女、未知
  );

  create table person2 (
         id int auto_increment primary key,
         name varchar(30) not null,
         gender enum('男', '女', '未知'), -- 限制，只有 男、女、未知
         country set('中国', '美国', '南非')
  );

  insert into person3 (name, gender, country) values ('灭绝', '女', '美国,南非');
#+END_SRC

* 主键

主键，primary key，从性能和实际出发，应该遵循下面几点:
1. 尽量短，避免占用太多空间
2. 唯一，不能跟其他行的数据重复
3. 不会改变
4. 代理键

所谓 *代理键* 是指跟业务无关的字段:
- 因为和业务无关，所以可以使用 int 等类型尽量短
- 因为和业务无关，所以可以避免因为业务变动引起的主键变化
- *不要相信自己的直觉，因为在直觉上感觉不会变的东西，往往都是经不起实践考验的*

* 表的修改的语法

基本语法:
#+BEGIN_SRC sql
  ALTER [ONLINE|OFFLINE] [IGNORE] TABLE tbl_name
      [alter_specification [, alter_specification] ...]
      [partition_options]

  alter_specification:
      table_options
    | ADD [COLUMN] col_name column_definition
          [FIRST | AFTER col_name]
    | ADD [COLUMN] (col_name column_definition,...)

    | ADD {INDEX|KEY} [index_name]
          [index_type] (key_part,...) [index_option] ...
    | ADD [CONSTRAINT [symbol]] PRIMARY KEY
          [index_type] (key_part,...) [index_option] ...
    | ADD [CONSTRAINT [symbol]]
          UNIQUE [INDEX|KEY] [index_name]
          [index_type] (key_part,...) [index_option] ...
    | ADD FULLTEXT [INDEX|KEY] [index_name]
          (key_part,...) [index_option] ...
    | ADD SPATIAL [INDEX|KEY] [index_name]
          (key_part,...) [index_option] ...
    | ADD [CONSTRAINT [symbol]]
          FOREIGN KEY [index_name] (col_name,...)
          reference_definition
    | ALGORITHM [=] {DEFAULT|INPLACE|COPY}
    | ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}
    | CHANGE [COLUMN] old_col_name new_col_name column_definition
          [FIRST|AFTER col_name]
    | [DEFAULT] CHARACTER SET [=] charset_name [COLLATE [=] collation_name]
    | CONVERT TO CHARACTER SET charset_name [COLLATE collation_name]
    | {DISABLE|ENABLE} KEYS
    | {DISCARD|IMPORT} TABLESPACE

    | DROP [COLUMN] col_name
    | DROP {INDEX|KEY} index_name
    | DROP PRIMARY KEY
    | DROP FOREIGN KEY fk_symbol

    | FORCE
    | LOCK [=] {DEFAULT|NONE|SHARED|EXCLUSIVE}
    | MODIFY [COLUMN] col_name column_definition
          [FIRST | AFTER col_name]
    | ORDER BY col_name [, col_name] ...
    | RENAME [TO|AS] new_tbl_name
    | ADD PARTITION (partition_definition)
    | DROP PARTITION partition_names
    | TRUNCATE PARTITION {partition_names | ALL}
    | COALESCE PARTITION number
    | REORGANIZE PARTITION partition_names INTO (partition_definitions)
    | EXCHANGE PARTITION partition_name WITH TABLE tbl_name
    | ANALYZE PARTITION {partition_names | ALL}
    | CHECK PARTITION {partition_names | ALL}
    | OPTIMIZE PARTITION {partition_names | ALL}
    | REBUILD PARTITION {partition_names | ALL}
    | REPAIR PARTITION {partition_names | ALL}
    | REMOVE PARTITIONING

  key_part:
      col_name [(length)] [ASC | DESC]

  index_type:
      USING {BTREE | HASH}

  index_option:
      KEY_BLOCK_SIZE [=] value
    | index_type
    | WITH PARSER parser_name
    | COMMENT 'string'

  table_options:
      table_option [[,] table_option] ...

  table_option:
      AUTO_INCREMENT [=] value
    | AVG_ROW_LENGTH [=] value
    | [DEFAULT] CHARACTER SET [=] charset_name
    | CHECKSUM [=] {0 | 1}
    | [DEFAULT] COLLATE [=] collation_name
    | COMMENT [=] 'string'
    | CONNECTION [=] 'connect_string'
    | {DATA|INDEX} DIRECTORY [=] 'absolute path to directory'
    | DELAY_KEY_WRITE [=] {0 | 1}
    | ENGINE [=] engine_name
    | INSERT_METHOD [=] { NO | FIRST | LAST }
    | KEY_BLOCK_SIZE [=] value
    | MAX_ROWS [=] value
    | MIN_ROWS [=] value
    | PACK_KEYS [=] {0 | 1 | DEFAULT}
    | PASSWORD [=] 'string'
    | ROW_FORMAT [=] {DEFAULT|DYNAMIC|FIXED|COMPRESSED|REDUNDANT|COMPACT}
    | STATS_AUTO_RECALC [=] {DEFAULT|0|1}
    | STATS_PERSISTENT [=] {DEFAULT|0|1}
    | STATS_SAMPLE_PAGES [=] value
    | TABLESPACE tablespace_name [STORAGE {DISK|MEMORY|DEFAULT}]
    | UNION [=] (tbl_name[,tbl_name]...)
#+END_SRC

基本示例:
#+BEGIN_SRC sql
  -- 添加列
  alter table person add column qq varchar(20);
  alter table person add qq varchar(20); -- 可以去掉 column 关键词
  alter table person add tel varchar(20) after gender; -- 指定位置
  alter table person add (xxx int, yyy int);

  -- 修改列
  ALTER TABLE t2 MODIFY a TINYINT NOT NULL, CHANGE b c CHAR(20);


  -- 删除主键
  alter table person change id id int; -- 需要将 auto_increment 去掉
  alter table person drop primary key;

  -- 增加主键
  alter table person add primary key (id);
  -- 增加/删除外键
  alter table book 
     add constraint fk_authorid
     foreign key (authorid)
     references author (authorid);
  -- 增加/删除索引
  ALTER TABLE t2 ADD INDEX (d), ADD UNIQUE (a);
  -- 重命名
  alter table rename to people;
#+END_SRC
* 其他命令



* 存储过程

#+BEGIN_SRC sql
  -- 存储过程的定义
  delimiter //                   -- 使用 delimiter 指令，将默认的分隔符(;)换为我们自定义的分隔符
  create procedure ppx1 (p int)  -- 创建存储过程，名字 ppx1, 一个入参 int 类型的 p
  begin                          -- 使用 begin 跟 end 将所有语句包括起来，相当于 {}
      set @x = 0;                -- set 是用来定义或者设置变量的值的，用户级别的变量，需要使用 @ 作为前缀
    
      repeat                     -- repeat .. until .. end repeat 这是使用循环的其中一种方式
        set @x = @x + 1;         -- 在循环体中，我们就可以进行我们不断重复的业务、事情了
      until @x > p end repeat;   -- 使用 until 表示循环结束的条件。类似于 while 循环中的 break
  end
  delimiter ;                    -- 过程定义完成后，需要将分隔符还原为默认(;)

  -- 调用存储过程
  call ppx1(100);

  -- 查看用户定义变量的值
  select @x;
#+END_SRC

求和 1-n:
#+BEGIN_SRC sql
  create procedure sum2 (y int)
  begin
    declare x int;  -- 声明局部变量
    set x = 0;      -- 为局部变量赋值
    set @sum = 0;
    repeat
    set x = x + 1;
    set @sum = @sum + x;
    until x >= y end repeat;
  end

#+END_SRC
